#ifndef BASILISK_HEADER_9
#define BASILISK_HEADER_9
#line 1 "/home/dahuanghhc/basilisk/src/draw.h"
/**
# Drawing functions for [Basilisk View](view.h) 
*/

#include "fractions.h"
#include "gl/font.h"

/**
# *clear()*: removes all objects previously drawn */

void clear()
{
  bview * view = get_view();
  if (view->active)
    view->active = false;
  draw();
}

/**
# *view()*: sets up viewing parameters

* *tx*, *ty*: shifts the camera center point.
* *fov*: changes the field-of-view.
* *quat[]*: the quaternion defining the camera angles.
* *sx*, *sy*, *sz*: stretch factors for each axis.
* *width*, *height*, *samples*: the width and height (in pixels) of
  the image to render (default is 800 x 800). The image can optionally
  be generated by first rendering an image with *samples* times more
  pixels in each direction followed by subsampling. This provides a
  form of
  [antialiasing](https://en.wikipedia.org/wiki/Spatial_anti-aliasing). Default
  is four samples.
* *bg[]*: an array of red, green, blue values between 0 and 1 which
  defines the background color.
* *theta*, *phi*, *psi*: [Euler-like
   angles](https://en.wikipedia.org/wiki/Euler_angles) (in radians),
   used (instead of *quat[]*) to define the camera angle.
* *relative*: whether the *theta* and *phi* angles are absolute or
   relative to the current position (i.e. increments of the current
   angles).
* *tz*, *near*, *far*: an alternative way of specifying the camera, 
   compatible with the camera parameters in interactive Basilisk View.
* *camera*: predefined camera angles: "left", "right", "top",
   "bottom", "front", "back" and "iso".
* *map*: an optional coordinate mapping function.
* *cache*: the maximum number of cached compiled expressions.
*/

struct _view_set {
  float tx, ty;
  float fov;
  float quat[4];
  float sx, sy, sz;
  unsigned width, height, samples;
  float bg[3];
  float theta, phi, psi;
  bool relative;
  float tz, near, far;
  float res;
  char * camera;
  void (* map) (coord *);
  int cache;
  float p1x, p1y, p2x, p2y; // for trackball
  bview * view;
};

void view (struct _view_set p)
{
  bview * v = p.view ? p.view : get_view();
  if (p.fov) {
    if (p.relative)
      v->fov += (0.1 + 3.*v->fov)*p.fov;
    else
      v->fov = p.fov;
    v->fov = clamp(v->fov,0.01,100.);
  }
  for (int i = 0; i < 4; i++)
    if (p.quat[i]) {
      for (int j = 0; j < 4; j++)
	v->quat[j] = p.quat[j];
      break;
    }
  if (p.tx) v->tx = p.relative ? v->tx + p.tx*0.02*(0.01 + 3.*v->fov) : p.tx;
  if (p.ty) v->ty = p.relative ? v->ty + p.ty*0.02*(0.01 + 3.*v->fov) : p.ty;
  if (p.sx) v->sx = p.sx;
  if (p.sy) v->sy = p.sy;
  if (p.sz) v->sz = p.sz;
  if (p.bg[0] || p.bg[1] || p.bg[2])
    for (int i = 0; i < 3; i++)
      v->bg[i] = p.bg[i];
  
  if (p.camera) {
    v->gfsview = false;
    if (strlen(p.camera) >= 4 &&
	!strcmp (&p.camera[strlen(p.camera) - 4], ".gfv")) {
      FILE * fp = fopen (p.camera, "r");
      if (!fp) {
	perror (p.camera);
	exit (1);
      }
      char s[81];
      float q[4], fov;
      int nq = 0, nf = 0;
      while (fgets (s, 81, fp) && (!nq || !nf)) {
	if (!nq)
	  nq = sscanf (s, "  q0 = %f q1 = %f q2 = %f q3 = %f",
		       &q[0], &q[1], &q[2], &q[3]);
	if (!nf)
	  nf = sscanf (s, "  fov = %f", &fov);
      }
      if (nq != 4 || nf != 1) {
	fprintf (stderr, "%s: not a valid gfv file\n", p.camera);
	exit (1);
      }
      for (int j = 0; j < 4; j++)
	v->quat[j] = q[j];
      v->fov = fov;
      v->gfsview = true;
    }
    else if (!strcmp (p.camera, "left"))
      gl_axis_to_quat ((float[]){0,1,0}, - pi/2., v->quat);
    else if (!strcmp (p.camera, "right"))
      gl_axis_to_quat ((float[]){0,1,0}, pi/2., v->quat);
    else if (!strcmp (p.camera, "top"))
      gl_axis_to_quat ((float[]){1,0,0}, - pi/2., v->quat);
    else if (!strcmp (p.camera, "bottom"))
      gl_axis_to_quat ((float[]){1,0,0}, pi/2., v->quat);
    else if (!strcmp (p.camera, "front"))
      gl_axis_to_quat ((float[]){0,0,1}, 0., v->quat);
    else if (!strcmp (p.camera, "back"))
      gl_axis_to_quat ((float[]){0,1,0}, pi, v->quat);
    else if (!strcmp (p.camera, "iso")) {
      gl_axis_to_quat ((float[]){0,1,0}, pi/4., v->quat);
      float q[4];
      gl_axis_to_quat ((float[]){1,0,0}, - pi/4., q);
      gl_add_quats(q, v->quat, v->quat);
    }
    else {
      fprintf (stderr, "view(): unknown camera '%s'\n", p.camera);
      exit (1);
    }
  }
  else if (p.theta || p.phi || p.psi) {
    v->gfsview = false;
    float q[4];
    gl_axis_to_quat ((float[]){1,0,0}, - p.phi, q);
    if (p.relative) {
      float q1[4];
      gl_axis_to_quat ((float[]){0,1,0}, p.theta, q1);
      gl_add_quats(q, q1, q1);
      float q2[4];
      gl_axis_to_quat ((float[]){0,0,1}, p.psi, q2);
      gl_add_quats(q1, q2, q2);
      gl_add_quats(q2, v->quat, v->quat);
    }
    else {
      gl_axis_to_quat ((float[]){0,1,0}, p.theta, v->quat);
      gl_add_quats(q, v->quat, v->quat);
      gl_axis_to_quat ((float[]){0,0,1}, p.psi, q);
      gl_add_quats(q, v->quat, v->quat);
    }
  }

  if (p.map)
    v->map = p.map;
  
  if (p.p1x || p.p1y || p.p2x || p.p2y) { // trackball
    float q[4];
    gl_trackball(q, p.p1x, p.p1y, p.p2x, p.p2y);
    gl_add_quats (q, v->quat, v->quat);
  }

  if (p.far > p.near) {
    v->tz = p.tz;
    v->far = p.far;
    v->near = p.near;
  }
  
  if (p.res)
    v->res = p.res;
  
  if ((p.width && p.width != v->width) ||
      (p.height && p.height != v->height) ||
      (p.samples && p.samples != v->samples)) {
    v->width = v->width/v->samples;
    v->height = v->height/v->samples;
    if (p.width) v->width = p.width;
    if (p.height) v->height = p.height;
    if (p.samples) v->samples = p.samples;
    v->width *= v->samples;
    v->height *= v->samples;
    framebuffer_destroy (v->fb);

    /* OpenGL somehow generates floating-point exceptions... turn them off */
    disable_fpe (FE_DIVBYZERO|FE_INVALID);
    
    v->fb = framebuffer_new (v->width, v->height);
    init_gl();

    enable_fpe (FE_DIVBYZERO|FE_INVALID);    
  }

  if (p.cache > 0) {
    v->cache = calloc (1, sizeof (cexpr));
    v->maxlen = p.cache;
  }
  
  clear();
}

/**
# *translate()*: translates the origin.

The block following this command will be drawn in a translated
coordinate system. */

struct _translate {
  float x, y, z;
};

void begin_translate (struct _translate p)
{
  bview * view = draw();
  glMatrixMode (GL_MODELVIEW);
  glPushMatrix();
  glTranslatef (p.x, p.y, p.z);
  gl_get_frustum (&view->frustum);
}

void end_translate()
{
  bview * view = draw();
  glMatrixMode (GL_MODELVIEW);
  glPopMatrix();
  gl_get_frustum (&view->frustum);
}

/**
# *mirror()*: symmetry relative to a plane.

The block following this command will be drawn in a coordinate system
symmetric relative to the given plane. The plane is given by $n$ and
$\alpha$ as explained in
[squares()](#squares-displays-colormapped-fields). */

struct _mirror {
  coord n;
  double alpha;
};

void begin_mirror (struct _mirror p)
{
  bview * view = draw();
  glMatrixMode (GL_MODELVIEW);
  glPushMatrix();
  normalize (&p.n);
  GLfloat s[16], t[16];
  s[0] = 1. - 2.*p.n.x*p.n.x;
  s[1] = - 2.*p.n.x*p.n.y;  s[2] = - 2.*p.n.x*p.n.z;
  s[3] = 0.;
  s[4] = s[1];
  s[5] = 1. - 2.*p.n.y*p.n.y; s[6] = - 2.*p.n.y*p.n.z;
  s[7] = 0.;
  s[8] = s[2];   s[9] = s[6];  s[10] = 1. - 2.*p.n.z*p.n.z; 
  s[11] = 0.;
  s[12] = 0.;    s[13] = 0.;   s[14] = 0.;                    
  s[15] = 1.;

  t[0] = 1.;  t[1] = 0.;   t[2] = 0.;  t[3] = 0.;
  t[4] = 0.;  t[5] = 1.;   t[6] = 0.;  t[7] = 0.;
  t[8] = 0.;  t[9] = 0.;   t[10] = 1.; t[11] = 0.;
  t[12] = - 2.*p.n.x*p.alpha; 
  t[13] = - 2.*p.n.y*p.alpha;  
  t[14] = - 2.*p.n.z*p.alpha; 
  t[15] = 1.;
  matrix_multiply (s, t);
  glMultMatrixf (s);
  gl_get_frustum (&view->frustum);
  view->reversed = !view->reversed;
}

void end_mirror() {
  end_translate();
  bview * view = draw();
  view->reversed = !view->reversed;
}

/**
# Utility functions

The tree structure is used to traverse only the cells which are within
the field of view of the camera. */

static void mapped_position (bview * view, coord * p, double * r)
{
  double x = p->x, y = p->y, z = p->z, rm = 0.;
  view->map (p);
  for (int i = -1; i <= 1; i += 2)
    for (int j = -1; j <= 1; j += 2)
      for (int k = -1; k <= 1; k += 2) {
	coord q = {x + i**r, y + j**r, z + k**r};
	view->map (&q);
	double pq = sq(p->x - q.x) + sq(p->y - q.y) + sq(p->z - q.z);
	if (pq > rm)
	  rm = pq;
      }
  *r = sqrt (rm);
}

@def foreach_visible(view)
foreach_cell() {
#if dimension == 2
  double _r = Delta*0.71;
#else // dimension == 3
  double _r = Delta*0.87;
#endif
  coord _p = {x, y, z};
  if ((view)->map)
    mapped_position (view, &_p, &_r);
  if (VertexBuffer.visible &&
      !sphere_in_frustum (_p.x, _p.y, _p.z, _r, &(view)->frustum))
    continue;
  if (is_leaf(cell) ||
      (VertexBuffer.visible &&
       sphere_diameter (_p.x, _p.y, _p.z, _r/L0, &(view)->frustum)
       < (view)->res)) {
    if (is_active(cell) && is_local(cell)) {
@
@def end_foreach_visible()
    }
    continue;
  }
}
end_foreach_cell();
@

/**
A similar technique can be used to traverse the cells which are both
visible and intersected by a plane defined by
$$
n_x x + n_y y + n_z z = \alpha
$$
*/

#if dimension == 3
static void glnormal3d (bview * view, double x, double y, double z) {
  // fixme: mapping? (see glvertex3d)
  if (view->gfsview || view->reversed)
    glNormal3d (- x, - y, - z);
  else
    glNormal3d (x, y, z);
}

@def foreach_visible_plane(view, n1, alpha1)
coord n = {(n1).x, (n1).y, (n1).z};
double _alpha = 0.9999999*(alpha1);
{
  double norm = sqrt(sq(n.x) + sq(n.y) + sq(n.z));
  if (!norm)
    n.z = 1.;
  else
    n.x /= norm, n.y /= norm, n.z /= norm, _alpha /= norm;
}
glnormal3d (view, n.x, n.y, n.z); // do not use normal inversion
foreach_cell() {
  // fixme: coordinate mapping
  double _r = Delta*0.87, alpha = (_alpha - n.x*x - n.y*y - n.z*z)/Delta;
  if (fabs(alpha) > 0.87 ||
      (VertexBuffer.visible &&
       !sphere_in_frustum (x, y, z, _r, &(view)->frustum)))
    continue;
  if (is_leaf(cell) ||
      (VertexBuffer.visible &&
       sphere_diameter (x, y, z, _r/L0, &(view)->frustum) < (view)->res)) {
    if (is_active(cell) && is_local(cell)) {
@
@def end_foreach_visible_plane()
    }
    continue;
  }
}
end_foreach_cell();
@
#endif // dimension == 3

static bool _reversed = false;

static void begin_draw_lines (bview * view, float color[3], float lw)
{
  glMatrixMode (GL_PROJECTION);
  glPushMatrix();
  glTranslatef (0., 0., view->lc*view->fov/24.);
  glColor3f (color[0], color[1], color[2]);
  glLineWidth (view->samples*(lw > 0. ? lw : 1.));
  _reversed = view->reversed;
  view->reversed = false;
}

static void end_draw_lines()
{    
  glMatrixMode (GL_PROJECTION);
  glPopMatrix();
  bview * view = draw();
  view->reversed = _reversed;
}

static inline double interp (Point point, coord p, scalar col) {
  struct _interpolate _r = { col, x + p.x*Delta, y + p.y*Delta, z + p.z*Delta };
  return interpolate_linear (point, _r);
}

static double evaluate_expression (Point point, Node * n)
{
  assert (n);
  switch (n->type) {
  case '1': return n->d.value;
  case '+': return (evaluate_expression (point, n->e[0]) +
		    evaluate_expression(point, n->e[1]));
  case '-': return (evaluate_expression (point, n->e[0]) -
		    evaluate_expression(point, n->e[1]));
  case '*': return (evaluate_expression (point, n->e[0]) *
		    evaluate_expression(point, n->e[1]));
  case '/': return (evaluate_expression (point, n->e[0]) /
		    evaluate_expression(point, n->e[1]));
  case '^': return pow (evaluate_expression (point, n->e[0]),
			evaluate_expression(point, n->e[1]));
  case '>': return (evaluate_expression (point, n->e[0]) >
		    evaluate_expression(point, n->e[1]));
  case '<': return (evaluate_expression (point, n->e[0]) <
		    evaluate_expression(point, n->e[1]));
  case 'L': return (evaluate_expression (point, n->e[0]) <=
		    evaluate_expression(point, n->e[1]));
  case 'G': return (evaluate_expression (point, n->e[0]) >=
		    evaluate_expression(point, n->e[1]));
  case '=': return (evaluate_expression (point, n->e[0]) ==
		    evaluate_expression(point, n->e[1]));
  case 'i': return (evaluate_expression (point, n->e[0]) !=
		    evaluate_expression(point, n->e[1]));
  case 'O': return (evaluate_expression (point, n->e[0]) ||
		    evaluate_expression(point, n->e[1]));
  case 'A': return (evaluate_expression (point, n->e[0]) &&
		    evaluate_expression(point, n->e[1]));
  case '?': return (evaluate_expression (point, n->e[0]) ?
		    evaluate_expression(point, n->e[1]) :
		    evaluate_expression(point, n->e[2]));
  case 'm': return - evaluate_expression (point, n->e[0]);
  case 'f': return n->d.func (evaluate_expression (point, n->e[0]));
  case 'v': {
    scalar s = {n->s};
    int k[3] = {0,0,0};
    for (int i = 0; i < 3; i++)
      if (n->e[i])
	k[i] = evaluate_expression (point, n->e[i]);
    return s[k[0],k[1],k[2]];
  }
  case 'D': return Delta;
  case 'x': return x;
  case 'y': return y;
  case 'z': return z;
  default:
    fprintf (stderr, "unknown operation type '%c'\n", n->type);
    assert (false);
  }
  return undefined;
}

static bool assemble_node (Node * n)
{
  if (n->type == 'v') {
    char * id = n->d.id;
    scalar s = lookup_field (id);
    if (s.i >= 0)
      n->s = s.i;
    else {
      n->s = -1;
      if (!strcmp (id, "Delta"))
	reset_node_type (n, 'D');
      else if (!strcmp (id, "x"))
	reset_node_type (n, 'x');
      else if (!strcmp (id, "y"))
	reset_node_type (n, 'y');
      else if (!strcmp (id, "z"))
	reset_node_type (n, 'z');
      else {
	typedef struct { char * name; double val; } Constant;
	static Constant constants[] = {
	  {"pi",     pi },
	  {"nodata", nodata },
	  {"HUGE",   HUGE },
	  { NULL },
	};
	Constant * p = constants;
	while (p->name) {
	  if (!strcmp (p->name, id)) {
	    reset_node_type (n, '1');
	    n->d.value = p->val;
	    break;
	  }
	  p++;
	}
	if (n->type == 'v') {
	  fprintf (stderr, "unknown identifier '%s'\n", id);
	  return false;
	}
      }	
    }    
  }
  for (int i = 0; i < 3; i++)
    if (n->e[i] && !assemble_node (n->e[i]))
      return false;
  return true;
}

static scalar compile_expression (char * expr, bool * isexpr)
{
  *isexpr = false;
  if (!expr)
    return (scalar){-1};
  
  bview * view = get_view();
  scalar s;
  if (view->cache && (s = get_cexpr (view->cache, expr)).i >= 0)
    return s;
  
  Node * node = parse_node (expr);
  if (node == NULL) {
    fprintf (stderr, "'%s': syntax error\n", expr);
    return (scalar){-1};
  }
  if (!assemble_node (node)) {
    free_node (node);
    return (scalar){-1};
  }
  if (node->type == 'v' && node->e[0] == NULL) {
    scalar s = {node->s};
    free_node (node);
    return s;
  }
  s = new scalar;
  free (s.name);
  s.name = strdup (expr);
  foreach()
    s[] = evaluate_expression (point, node);
  restriction ({s});
  free_node (node);
  
  if (view->cache)
    view->cache = add_cexpr (view->cache, view->maxlen, expr, s);
  else
    *isexpr = true;
  return s;
}

#define colorize_args(args)						\
  scalar col = {-1};							\
  if (args.color && strcmp (args.color, "level")) {			\
    col = compile_expression (args.color, &args.expr);			\
    if (col.i < 0)							\
      return false;							\
    boundary ({col});							\
  }									\
									\
  double cmap[NCMAP][3];						\
  if (args.color) {							\
    if (args.min == 0 && args.max == 0) {				\
      if (col.i < 0) /* level */					\
	args.min = 0, args.max = depth();				\
      else {								\
	stats s = statsf (col);						\
	double avg = s.sum/s.volume;					\
	if (args.spread < 0.)						\
	  args.min = s.min, args.max = s.max;				\
	else {								\
	  if (!args.spread) args.spread = 5.;				\
	  double spread = args.spread*s.stddev;				\
	  args.min = avg - spread; args.max = avg + spread;		\
	}								\
      }									\
    }									\
    if (!args.map)							\
      args.map = jet;							\
    args.map (cmap);							\
  }									\
  									\
  if ((dimension > 2 || args.linear) &&					\
      !args.fc[0] && !args.fc[1] && !args.fc[2])			\
    args.fc[0] = args.fc[1] = args.fc[2] = 1.;

#define color_facet(args)						\
  if (args.color && (!args.linear || col.i < 0)) {			\
    color b = colormap_color (cmap, col.i < 0 ?				\
			      (double) level : val(col,0,0,0),		\
			      args.min, args.max);			\
    glColor3f (b.r/255., b.g/255., b.b/255.);				\
  }

#define color_vertex(args, val)						\
  if (args.color && args.linear && col.i >= 0) {			\
    if (VertexBuffer.color) {						\
      color b = colormap_color (cmap, val, args.min, args.max);		\
      glColor3f (b.r/255., b.g/255., b.b/255.);				\
    }									\
    else {								\
      double _v = val;							\
      glTexCoord1d (clamp(((_v) - args.min)/(args.max - args.min), 0., 1.)); \
    }									\
  }

static void begin_colorized (float fc[3], bool constant_color,
			     double cmap[NCMAP][3], bool use_texture)
{
  // do not use textures for vector graphics
  if (use_texture) {
    GLfloat texture[3*256];
    for (int i = 0; i < 256; i++) {
      color j = colormap_color (cmap, i/255., 0, 1);
      texture[3*i] = j.r/255.;
      texture[3*i + 1] = j.g/255.;
      texture[3*i + 2] = j.b/255.;
    }
    glTexImage1D (GL_TEXTURE_1D, 0, GL_RGB, 256,0, GL_RGB, GL_FLOAT, texture);
    glTexParameteri (GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri (GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri (GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri (GL_TEXTURE_1D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glEnable (GL_TEXTURE_1D);
  }
  if (constant_color)
    glColor3f (fc[0], fc[1], fc[2]);
}

static void end_colorized() {
  glDisable (GL_TEXTURE_1D);
}

#define colorize() colorized (p.fc, !VertexBuffer.color || !p.color,	\
			      cmap, !VertexBuffer.color &&		\
			      p.color && p.linear && col.i >= 0)

/**
# *draw_vof()*: displays VOF-reconstructed interfaces

* *c*: the name (as a string) of the Volume-Of-Fluid field.
* *s*: the (optional) name of the face fraction field.
* *edges*: whether to display the edges or the facets.
* *larger*: makes each cell larger by this factor. This helps close
   the gaps in the VOF interface representation. Default is 1.1 in 3D
   and when edges are not displayed, otherwise it is 1.
* *filled*: in 2D, whether to fill the inside (1) or outside (-1).
* *color*: use this field to color each interface fragment.
* *min*, *max*: the minimum and maximum values to use for color mapping.
* *spread*: the "spread factor" to use if *min* and *max* are not
   defined. The maximum and minimum values will be taken as the average
   plus or minus *spread* times the standard deviation. Default is 5. If
   negative, the minimum and maximum values of the field are used.
* *linear*: if *true* the color will be linearly interpolated for each
   vertex of the facet.
* *map*: the colormap to use. Default is *jet*.
* *fc[]*: an array of red, green, blue values between 0 and 1 which
  defines the facet color.
* *lc[]*: an array of red, green, blue values between 0 and 1 which
  defines the line color.
* *lw*: the line width.
*/

struct _draw_vof {
  char * c;
  char * s;
  bool edges;
  double larger;
  int filled;

  char * color;
  double min, max, spread;
  bool linear;
  colormap map;
  float fc[3], lc[3], lw;
  bool expr;
};

/**
The somewhat complicated function below checks whether an interface
fragment is present within a given cell. The interface is defined by
the volume fraction field *c*. *cmin* is the threshold below which a
fragment is considered too small. */

static bool cfilter (Point point, scalar c, double cmin)
{
  double cmin1 = 4.*cmin;
  if (c[] <= cmin) {
    foreach_dimension()
      if (c[1] >= 1. - cmin1 || c[-1] >= 1. - cmin1)
	return true;
    return false;
  }
  if (c[] >= 1. - cmin) {
    foreach_dimension()
      if (c[1] <= cmin1 || c[-1] <= cmin1)
	return true;
    return false;
  }
  int n = 0;
  double min = HUGE, max = - HUGE;
  foreach_neighbor(1) {
    if (c[] > cmin && c[] < 1. - cmin && ++n >= (1 << dimension))
      return true;
    if (c[] > max) max = c[];
    if (c[] < min) min = c[];
  }
  return max - min > 0.5;
}

static void glvertex3d (bview * view, double x, double y, double z) {
  if (view->map) {
    coord p = {x, y, z};
    view->map (&p);
    glVertex3d (p.x, p.y, p.z);
  }
  else
    glVertex3d (x, y, z);
}

#if dimension <= 2
static void glvertex2d (bview * view, double x, double y) {
  if (view->map) {
    coord p = {x, y, 0.};
    view->map (&p);
    glVertex2d (p.x, p.y);
  }
  else
    glVertex2d (x, y);
}

static void glvertex_normal3d (bview * view, Point point, vector n,
			       double xp, double yp, double zp)
{
  coord v = {(xp - x)/Delta, (yp - y)/Delta}, np;
  foreach_dimension()
    np.x = - interp (point, v, n.x);
  glNormal3d (np.x, np.y, 1.);
  glvertex3d (view, xp, yp, zp);
}
#endif // dimension <= 2

trace
bool draw_vof (struct _draw_vof p)
{
  scalar c = lookup_field (p.c);
  if (c.i < 0) {
    fprintf (stderr, "draw_vof(): no field named '%s'\n", p.c);
    return false;
  }
  face vector s = lookup_vector (p.s);
  
  colorize_args (p);
  
  double cmin = 1e-3; // do not reconstruct fragments smaller than this

#if TREE
  // make sure we prolongate properly
  void (* prolongation) (Point, scalar) = c.prolongation;
  if (prolongation != fraction_refine) {
    c.prolongation = fraction_refine;
    c.dirty = true;
  }
#endif // TREE
    
  bview * view = draw();
#if dimension == 2
  if (p.filled) {
    glColor3f (p.fc[0], p.fc[1], p.fc[2]);
    glNormal3d (0, 0, view->reversed ? -1 : 1);
    foreach_visible (view) {
      if ((p.filled > 0 && c[] >= 1.) || (p.filled < 0 && c[] <= 0.)) {
	glBegin (GL_QUADS);
	glvertex2d (view, x - Delta_x/2., y - Delta_y/2.);
	glvertex2d (view, x + Delta_x/2., y - Delta_y/2.);
	glvertex2d (view, x + Delta_x/2., y + Delta_y/2.);
	glvertex2d (view, x - Delta_x/2., y + Delta_y/2.);
	glEnd();
	view->ni++;
      }
      else if (c[] > 0. && c[] < 1.) {
	coord n = facet_normal (point, c, s), r = {1.,1.};
	if (p.filled < 0)
	  foreach_dimension()
	    n.x = - n.x;
	double alpha = plane_alpha (p.filled < 0. ? 1. - c[] : c[], n);
	alpha += (n.x + n.y)/2.;
	foreach_dimension()
	  if (n.x < 0.) alpha -= n.x, n.x = - n.x, r.x = - 1.;
	coord v[5];
	int nv = 0;
	if (alpha >= 0. && alpha <= n.x) {
	  v[nv].x = alpha/n.x, v[nv++].y = 0.;
	  if (alpha <= n.y)
	    v[nv].x = 0., v[nv++].y = alpha/n.y;
	  else if (alpha >= n.y && alpha - n.y <= n.x) {
	    v[nv].x = (alpha - n.y)/n.x, v[nv++].y = 1.;
	    v[nv].x = 0., v[nv++].y = 1.;
	  }
	  v[nv].x = 0., v[nv++].y = 0.;
	}
	else if (alpha >= n.x && alpha - n.x <= n.y) {
	  v[nv].x = 1., v[nv++].y = (alpha - n.x)/n.y;
	  if (alpha >= n.y && alpha - n.y <= n.x) {
	    v[nv].x = (alpha - n.y)/n.x, v[nv++].y = 1.;
	    v[nv].x = 0., v[nv++].y = 1.;
	  }
	  else if (alpha <= n.y)
	    v[nv].x = 0., v[nv++].y = alpha/n.y;
	  v[nv].x = 0., v[nv++].y = 0.;
	  v[nv].x = 1., v[nv++].y = 0.;
	}
	glBegin (GL_POLYGON);
	if (r.x*r.y < 0.)
	  for (int i = nv - 1; i >= 0; i--)
	    glvertex2d (view, x + r.x*(v[i].x - 0.5)*Delta,
			y + r.y*(v[i].y - 0.5)*Delta);
	else
	  for (int i = 0; i < nv; i++)
	    glvertex2d (view, x + r.x*(v[i].x - 0.5)*Delta,
			y + r.y*(v[i].y - 0.5)*Delta);
	glEnd ();
	view->ni++;
      }
    }
  }
  else // !p.filled
    draw_lines (view, p.lc, p.lw) {
      glBegin (GL_LINES);
      foreach_visible (view)
	if (cfilter (point, c, cmin)) {
	  coord n = facet_normal (point, c, s);
	  double alpha = plane_alpha (c[], n);
	  coord segment[2];
	  if (facets (n, alpha, segment) == 2) {
	    glvertex2d (view, x + segment[0].x*Delta, y + segment[0].y*Delta);
	    glvertex2d (view, x + segment[1].x*Delta, y + segment[1].y*Delta);
	    view->ni++;
	  }
	}
      glEnd ();
    }
#else // dimension == 3
  double larger =
    p.larger ? p.larger : p.edges || (p.color && !p.linear) ? 1. : 1.1;
  if (p.edges)
    draw_lines (view, p.lc, p.lw) {
      foreach_visible (view)
	if (cfilter (point, c, cmin)) {
	  coord n = facet_normal (point, c, s);
	  double alpha = plane_alpha (c[], n);
	  coord v[12];
	  int m = facets (n, alpha, v, larger);
	  if (m > 2) {
	    glBegin (GL_LINE_LOOP);
	    for (int i = 0; i < m; i++)
	      glvertex3d (view,
			  x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
	    glEnd ();
	    view->ni++;
	  }
	}
    }
  else // !p.edges
    colorize() {
      foreach_visible (view)
	if (cfilter (point, c, cmin)) {
	  coord n = facet_normal (point, c, s);
	  double alpha = plane_alpha (c[], n);
	  coord v[12];
	  int m = facets (n, alpha, v, larger);
	  if (m > 2) {
	    glBegin (GL_POLYGON);
	    for (int i = 0; i < m; i++) {
	      if (p.linear) {
		color_vertex (p, interp (point, v[i], col));
	      }
	      else {
		color_facet (p);
	      }
	      glnormal3d (view, n.x, n.y, n.z);
	      glvertex3d (view,
			  x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
	    }
	    glEnd ();
	    view->ni++;
	  }
	}
    }
#endif // dimension == 3

#if TREE
  // revert prolongation
  if (prolongation != fraction_refine) {
    c.prolongation = prolongation;
    c.dirty = true;
  }
#endif // TREE

  if (p.expr) delete({col});
  return true;
}

/**
# *isoline()*: displays isolines

Draws a single isoline at *val* of field *phi*, or *n* isolines
between *min* and *max* (included).

Extra parameters are the same as for
[draw_vof()](draw.h#draw_vof-displays-vof-reconstructed-interfaces). */

struct _isoline {
  char * phi;
  double val;
  int n;
  
  // all fields below must be identical to struct _draw_vof above
  char * c;
  char * s;
  bool edges;
  double larger;
  int filled;

  char * color;
  double min, max, spread;
  bool linear;
  colormap map;
  float fc[3], lc[3], lw;
  bool expr;
};

trace
bool isoline (struct _isoline p)
{
#if dimension == 2
  if (!p.color) p.color = p.phi;
  colorize_args (p);
  scalar phi = col, fiso[];
  face vector siso[];
  p.c = "fiso", p.s = "siso";
  struct _draw_vof a = *((struct _draw_vof *)&p.c);
  if (p.n < 2) {
    fractions (phi, fiso, siso, p.val);
    draw_vof (a);
  }
  else if (p.max > p.min) {
    double dv = (p.max - p.min)/(p.n - 1);
    for (p.val = p.min; p.val <= p.max; p.val += dv) {
      fractions (phi, fiso, siso, p.val);
      draw_vof (a);
    }
  }
  if (p.expr) delete({col});
#else // dimension == 3
  assert (false);
#endif // dimension == 3
  return true;
}

/**
# *cells()*: displays grid cells

In 3D the intersections of the cells with a plane are displayed. The
default plane is $z=0$. This can be changed by setting *n* and *alpha*
which define the plane
$$
n_x x + n_y y + n_z z = \alpha
$$
*/

struct _cells {
  coord n;
  double alpha;
  float lc[3], lw; // the line color and width
};

trace
bool cells (struct _cells p)
{
  bview * view = draw();
  draw_lines (view, p.lc, p.lw) {
#if dimension == 2
    foreach_visible (view) {
      glBegin (GL_LINE_LOOP);
      glvertex2d (view, x - Delta_x/2., y - Delta_y/2.);
      glvertex2d (view, x + Delta_x/2., y - Delta_y/2.);
      glvertex2d (view, x + Delta_x/2., y + Delta_y/2.);
      glvertex2d (view, x - Delta_x/2., y + Delta_y/2.);
      glEnd();
      view->ni++;
    }
#else // dimension == 3
    foreach_visible_plane (view, p.n, p.alpha) {
      coord v[12];
      int m = facets (n, alpha, v, 1.);
      if (m > 2) {
	glBegin (GL_LINE_LOOP);
	for (int i = 0; i < m; i++)
	  glvertex3d (view, x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
	glEnd ();
	view->ni++;
      }
    }
#endif // dimension == 3
  }
  return true;
}

/**
# *vectors()*: displays vector fields

The vectors are scaled using the *scale* factor. */

struct _vectors {
  char * u;
  double scale;    // default is one
  float lc[3], lw; // the line color and width
};

trace
bool vectors (struct _vectors p)
{
#if dimension == 2
  vector u;
  struct { char x, y, z; } index = {'x', 'y', 'z'};
  foreach_dimension() {
    char name[80];
    sprintf (name, "%s.%c", p.u, index.x);
    u.x = lookup_field (name);
  }
  bview * view = draw();
  float res = view->res;
  if (view->res < 15*view->samples)
    view->res = 15*view->samples;
  draw_lines (view, p.lc, p.lw) {
    double scale = (p.scale ? p.scale : 1.)*view->res/view->samples;
    glBegin (GL_LINES);
    foreach_visible (view)
      if (u.x[] != nodata) {
	coord f = { scale*u.x[], scale*u.y[] };
	glvertex2d (view, x + f.x - (f.x - f.y/2.)/5.,
		    y + f.y - (f.x/2. + f.y)/5.);
	glvertex2d (view, x + f.x, y + f.y);
	glvertex2d (view, x + f.x, y + f.y);
	glvertex2d (view, x + f.x - (f.x + f.y/2.)/5.,
		    y + f.y + (f.x/2. - f.y)/5.);
	glvertex2d (view, x, y);
	glvertex2d (view, x + f.x, y + f.y);	
	view->ni++;
      }
    glEnd();
  }
  view->res = res;
#else // dimension == 3
  fprintf (stderr, "vectors() is not implemented in 3D yet\n");
#endif // dimension == 3
  return true;
}
  
/**
# *squares()*: displays colormapped fields

The field name is given by *color*. The *min*, *max*, *spread*, *map*
etc.  arguments work as described in
[draw_vof()](draw.h#draw_vof-displays-vof-reconstructed-interfaces).

In 2D, if *z* is specified, and *linear* is the true, the corresponding
expression is used as z-coordinate.

In 3D the intersections of the field with a plane are displayed. The
default plane is $z=0$. This can be changed by setting *n* and *alpha*
which define the plane
$$
n_x x + n_y y + n_z z = \alpha
$$
*/

struct _squares {
  char * color;
  char * z;
  double min, max, spread;
  bool linear;
  colormap map;
  float fc[3], lc[3];
  bool expr;
  
  coord n;
  double alpha;
};

trace
bool squares (struct _squares p)
{
#if dimension == 2
  scalar Z = {-1};
  vector n;
  bool zexpr = false;
  if (p.z) {
    Z = compile_expression (p.z, &zexpr);
    if (Z.i < 0)
      return false;
    n = new vector;
    foreach()
      foreach_dimension()
        n.x[] = (Z[1] - Z[-1])/(2.*Delta_x);
  }
#endif
  colorize_args (p);
  scalar f = col;
  
  bview * view = draw();
  glShadeModel (GL_SMOOTH);
  if (p.linear) {
    colorize() {
#if dimension == 2
      if (Z.i < 0) {
	glNormal3d (0, 0, view->reversed ? -1 : 1);
	foreach_visible (view)
	  if (f[] != nodata) {
	    glBegin (GL_TRIANGLE_FAN);
	    color_vertex (p,
			  (4.*f[] +
			   2.*(f[1] + f[-1] + f[0,1] + f[0,-1]) +
			   f[-1,-1] + f[1,1] + f[-1,1] + f[1,-1])/16.
			  );
	    glvertex2d (view, x, y);
	    color_vertex (p, (f[] + f[-1] + f[-1,-1] + f[0,-1])/4.);
	    glvertex2d (view, x - Delta_x/2., y - Delta_y/2.);
	    color_vertex (p, (f[] + f[1] + f[1,-1] + f[0,-1])/4.);
	    glvertex2d (view, x + Delta_x/2., y - Delta_y/2.);
	    color_vertex (p, (f[] + f[1] + f[1,1] + f[0,1])/4.);
	    glvertex2d (view, x + Delta_x/2., y + Delta_y/2.);
	    color_vertex (p, (f[] + f[-1] + f[-1,1] + f[0,1])/4.);
	    glvertex2d (view, x - Delta_x/2., y + Delta_y/2.);
	    color_vertex (p, (f[] + f[-1] + f[-1,-1] + f[0,-1])/4.);
	    glvertex2d (view, x - Delta_x/2., y - Delta_y/2.);
	    glEnd();
	    view->ni++;
	  }
      }
      else // Z.i > 0
	foreach_leaf() // fixme: foreach_visible() would be better
	  if (f[] != nodata) {
	    glBegin (GL_TRIANGLE_FAN);
	    color_vertex (p, (4.*f[] +
			      2.*(f[1] + f[-1] + f[0,1] + f[0,-1]) +
			      f[-1,-1] + f[1,1] + f[-1,1] + f[1,-1])/16.);
	    glvertex_normal3d (view, point, n, x, y, Z[]);
	    color_vertex (p, (f[] + f[-1] + f[-1,-1] + f[0,-1])/4.);
	    glvertex_normal3d (view, point, n, x - Delta_x/2., y - Delta_y/2.,
			       (Z[] + Z[-1] + Z[-1,-1] + Z[0,-1])/4.);
	    color_vertex (p, (f[] + f[1] + f[1,-1] + f[0,-1])/4.);
	    glvertex_normal3d (view, point, n, x + Delta_x/2., y - Delta_y/2.,
			       (Z[] + Z[1] + Z[1,-1] + Z[0,-1])/4.);
	    color_vertex (p, (f[] + f[1] + f[1,1] + f[0,1])/4.);
	    glvertex_normal3d (view, point, n, x + Delta_x/2., y + Delta_y/2.,
			       (Z[] + Z[1] + Z[1,1] + Z[0,1])/4.);
	    color_vertex (p, (f[] + f[-1] + f[-1,1] + f[0,1])/4.);
	    glvertex_normal3d (view, point, n, x - Delta_x/2., y + Delta_y/2.,
			       (Z[] + Z[-1] + Z[-1,1] + Z[0,1])/4.);
	    color_vertex (p, (f[] + f[-1] + f[-1,-1] + f[0,-1])/4.);
	    glvertex_normal3d (view, point, n, x - Delta_x/2., y - Delta_y/2.,
			       (Z[] + Z[-1] + Z[-1,-1] + Z[0,-1])/4.);
	    glEnd();
	    view->ni++;	    
	  }
#else // dimension == 3
      foreach_visible_plane (view, p.n, p.alpha)
	if (f[] != nodata) {
	  coord v[12];
	  int m = facets (n, alpha, v, 1.);
	  if (m > 2) {
	    coord c = {0,0,0};
	    for (int i = 0; i < m; i++)
	      foreach_dimension()
		c.x += v[i].x/m;
	    glBegin (GL_TRIANGLE_FAN);
	    color_vertex (p, interp (point, c, f));
	    glvertex3d (view, x + c.x*Delta, y + c.y*Delta, z + c.z*Delta);
	    for (int i = 0; i < m; i++) {
	      color_vertex (p, interp (point, v[i], f));
	      glvertex3d (view,
			  x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
	    }
	    color_vertex (p, interp (point, v[0], f));
	    glvertex3d (view,
			x + v[0].x*Delta, y + v[0].y*Delta, z + v[0].z*Delta);
	    glEnd ();
	    view->ni++;
	  }
	}
#endif // dimension == 3
    }
  }
  else { // !p.linear
#if dimension == 2
    glNormal3d (0, 0, view->reversed ? -1 : 1);
    glBegin (GL_QUADS);
    foreach_visible (view)
      if (f[] != nodata) {
	color_facet (p);
	glvertex2d (view, x - Delta_x/2., y - Delta_y/2.);
	color_facet (p);
	glvertex2d (view, x + Delta_x/2., y - Delta_y/2.);
	color_facet (p);
	glvertex2d (view, x + Delta_x/2., y + Delta_y/2.);
	color_facet (p);
	glvertex2d (view, x - Delta_x/2., y + Delta_y/2.);
	view->ni++;
      }
    glEnd();
#else // dimension == 3
    foreach_visible_plane (view, p.n, p.alpha)
      if (f[] != nodata) {
	coord v[12];
	int m = facets (n, alpha, v, 1.);
	if (m > 2) {
	  glBegin (GL_POLYGON);
	  for (int i = 0; i < m; i++) {
	    color_facet (p);
	    glvertex3d (view,
			x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
	  }
	  glEnd ();
	  view->ni++;
	}
      }
#endif // dimension == 3
  }
  if (p.expr) delete ({col});
#if dimension == 2
  if (zexpr) delete ({Z});
  if (p.z) delete ((scalar *){n});
#endif
  return true;
}

/**
# *box()*: displays box boundaries and axis coordinates

* *notics*: do not draw tick marks (default is false).
* *lc[]*: an array of red, green, blue values between 0 and 1 which
  defines the line color.
* *lw*: the line width.
*/

struct _box {
  bool notics;
  float lc[3], lw;
};
	  
trace
bool box (struct _box p)
{
  bview * view = draw();
  draw_lines (view, p.lc, p.lw) {

    float height = 0.5*gl_StrokeHeight();
    float width = gl_StrokeWidth ('1'), scale = L0/(60.*width), length;
    float Z1 = dimension == 2 ? 0. : Z0;
    char label[80];
  
    glMatrixMode (GL_MODELVIEW);

    if (!p.notics) {
      int nt = 8;
      for (int i = 0; i <= nt; i++) {
	glPushMatrix();
	glTranslatef (X0 + i*L0/nt - height/2.*scale, Y0 - width/3.*scale, Z1);
	glRotatef (-90, 0, 0, 1);
	glScalef (scale, scale, 1.);
	sprintf (label, "%g", X0 + i*L0/nt);
	gl_StrokeString (label);
	glPopMatrix();

	glPushMatrix();
	sprintf (label, "%g", Y0 + i*L0/nt);
	length = gl_StrokeLength (label);
	glTranslatef (X0 - (length + width/3.)*scale,
		      Y0 + i*L0/nt - height/2.*scale, Z1);
	glScalef (scale, scale, 1.);
	gl_StrokeString (label);
	glPopMatrix();

#if dimension > 2
	glPushMatrix();
	sprintf (label, "%g", Z0 + i*L0/nt);
	length = gl_StrokeLength (label);
	glTranslatef (X0 - (length + width/3.)*scale,
		      Y0, Z0 + i*L0/nt + height/2.*scale);
	glRotatef (-90, 1, 0, 0);
	glScalef (scale, scale, 1.);
	gl_StrokeString (label);
	glPopMatrix();
#endif
      }

      glPushMatrix();
      sprintf (label, "%g", X0 + L0/2.);
      length = gl_StrokeLength (label);
      glTranslatef (X0 + L0/2 - height*scale, Y0 - (length + 4.*width)*scale, Z1);
      glScalef (2.*scale, 2.*scale, 1.);
      gl_StrokeString ("X");
      glPopMatrix();

  
      glPushMatrix();
      sprintf (label, "%g", Y0 + L0/2.);
      length = gl_StrokeLength (label);
      glTranslatef (X0 - (length + 4.*width)*scale,
		    Y0 + L0/2. - height*scale, Z1);
      glScalef (2.*scale, 2.*scale, 1.);
      gl_StrokeString ("Y");
      glPopMatrix();

#if dimension > 2
      glPushMatrix();
      sprintf (label, "%g", Z0 + L0/2.);
      length = gl_StrokeLength (label);
      glTranslatef (X0 - (length + 4.*width)*scale,
		    Y0, Z0 + L0/2. + height*scale);
      glRotatef (-90, 1, 0, 0);
      glScalef (2.*scale, 2.*scale, 1.);
      gl_StrokeString ("Z");
      glPopMatrix();
#endif
    }
  
#if dimension == 2
    foreach_level (0) {
      glBegin (GL_LINE_LOOP);
      glvertex2d (view, x - Delta_x/2., y - Delta_y/2.);
      glvertex2d (view, x + Delta_x/2., y - Delta_y/2.);
      glvertex2d (view, x + Delta_x/2., y + Delta_y/2.);
      glvertex2d (view, x - Delta_x/2., y + Delta_y/2.);
      glEnd ();
      view->ni++;
    }  
#else // dimension != 2
    foreach_level (0) {
      for (int i = -1; i <= 1; i += 2) {
	glBegin (GL_LINE_LOOP);
	glvertex3d (view, x - Delta_x/2., y - Delta_y/2., z + i*Delta/2.);
	glvertex3d (view, x + Delta_x/2., y - Delta_y/2., z + i*Delta/2.);
	glvertex3d (view, x + Delta_x/2., y + Delta_y/2., z + i*Delta/2.);
	glvertex3d (view, x - Delta_x/2., y + Delta_y/2., z + i*Delta/2.);
	glEnd ();
	view->ni++;
	glBegin (GL_LINES);
	for (int j = -1; j <= 1; j += 2) {
	  glvertex3d (view, x + i*Delta/2., y + j*Delta/2., z - Delta/2.);
	  glvertex3d (view, x + i*Delta/2., y + j*Delta/2., z + Delta/2.);
	}
	glEnd ();
	view->ni++;
      }
    }
#endif // dimension != 2
  }
  return true;
}

/**
# *isosurface()*: displays an isosurface of a field

* *f*: the name (as a string) of the field.
* *v*: the value of the isosurface.
* *edges*: whether to draw the edges of isosurface facets.
* *color*: use this field to color each interface fragment.

The *min*, *max*, *spread*, *map* etc.  arguments work as described in
[draw_vof()](draw.h#draw_vof-displays-vof-reconstructed-interfaces). */

struct _isosurface {
  char * f;
  double v;
  
  char * color;
  double min, max, spread;
  bool linear;
  colormap map;
  float fc[3], lc[3], lw;
  bool expr;
};

trace
bool isosurface (struct _isosurface p)
{
#if dimension > 2
  if (!p.f)
    return false;
  
  scalar f = {-1};
  bool fexpr;
  if (strcmp (p.f, "level")) {
    f = compile_expression (p.f, &fexpr);
    if (f.i < 0)
      return false;
  }

  colorize_args (p);

  vertex scalar v[];
  foreach_vertex()
    v[] = (f[] + f[-1] + f[0,-1] + f[-1,-1] +
	   f[0,0,-1] + f[-1,0,-1] + f[0,-1,-1] + f[-1,-1,-1])/8.;
  
  vector n[];
  foreach()
    foreach_dimension()
      n.x[] = center_gradient(f);
  boundary ({n}); // fixme: not detected by interp() below

  bview * view = draw();
  glShadeModel (GL_SMOOTH);
  colorize() {
    foreach_visible (view) {
      double val[8] = {
	v[0,0,0], v[1,0,0], v[1,0,1], v[0,0,1],
	v[0,1,0], v[1,1,0], v[1,1,1], v[0,1,1]
      };
      double t[5][3][3];
      int nt = polygonize (val, p.v, t);
      for (int i = 0; i < nt; i++) {
	color_facet (p);
	glBegin (GL_POLYGON);
	for (int j = 0; j < 3; j++) {
	  coord v = {t[i][j][0], t[i][j][1], t[i][j][2]}, np;
	  foreach_dimension()
	    np.x = interp (point, v, n.x);
	  glnormal3d (view, np.x, np.y, np.z);
	  if (p.linear) {
	    color_vertex (p, interp (point, v, col));
	  }
	  else {
	    color_facet (p);
	  }
	  glvertex3d (view, x + v.x*Delta_x, y + v.y*Delta_y, z + v.z*Delta_z);
	}
	glEnd ();
	view->ni++;
      }
    }
  }
  if (p.expr) delete ({col});
  if (fexpr) delete ({f});
#endif // dimension > 2
  return true;
}

/**
# *travelling()*: moves the camera to a different viewpoint

* *start*: starting time of the camera motion.
* *end*: time at which the viewpoint should be reached.
* *tx*, *ty*, *quat*, *fov*: definition of the target viewpoint.
*/

struct _travelling {
  double start, end;
  float tx, ty, quat[4], fov;
};

#define interpo(v)							\
  (!p.v ? v : ((t - p.start)*(p.v) + (p.end - t)*(v))/(p.end - p.start))

void travelling (struct _travelling p)
{
  static float tx, ty, quat[4], fov;
  static double told = -1.;
  if (told < p.start && t >= p.start) {
    bview * view = get_view();
    tx = view->tx, ty = view->ty, fov = view->fov;
    for (int i = 0; i < 4; i++)
      quat[i] = view->quat[i];
  }
  if (t >= p.start && t <= p.end)
    view (tx = interpo (tx), ty = interpo (ty),
	  fov = interpo (fov),
	  quat = {interpo(quat[0]), interpo(quat[1]),
	          interpo(quat[2]), interpo(quat[3])});
  if (told < p.end && t >= p.end) {
    bview * view = get_view();
    tx = view->tx, ty = view->ty, fov = view->fov;
    for (int i = 0; i < 4; i++)
      quat[i] = view->quat[i];
  }  
  told = t;  
}

#undef interpo

/**
# *draw_string()*: draws strings on a separate layer (for annotations)

* *str*: string to display.
* *pos*: position: "0" bottom left, "1" top left, "2" top right 
  and "3" bottom right (default 0).
* *size*: the size of the text, given as the number of characters
   which can fit within the width of the screen. Default is 40.
* *lc[]*: an array of red, green, blue values between 0 and 1 which
  defines the text color.
* *lw*: the line width.
*/

struct _draw_string {
  char * str;
  int pos;
  float size;
  float lc[3], lw;
};

trace
bool draw_string (struct _draw_string p)
{
  bview * view = draw();
  
  glMatrixMode (GL_PROJECTION);
  glPushMatrix();             
  glLoadIdentity();

  glMatrixMode (GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
    
  glColor3f (p.lc[0], p.lc[1], p.lc[2]);
  glLineWidth (view->samples*(p.lw > 0. ? p.lw : 1.));

  float width  = gl_StrokeWidth ('1'), height = gl_StrokeHeight();
  if (!p.size)
    p.size = 40;
  float hscale = 2./(p.size*width), vscale = hscale*view->width/view->height;
  float vmargin = width/2.*vscale;
  if (p.pos == 0)
    glTranslatef (-1., -1. + vmargin, 0.);
  else if (p.pos == 1)
    glTranslatef (-1., 1. - height*vscale, 0.);
  else if (p.pos == 2)
    glTranslatef (1. - strlen(p.str)*width*hscale, 1. - height*vscale, 0.);
  else
    glTranslatef (1. - strlen(p.str)*width*hscale, -1. + vmargin, 0.);    
  glScalef (hscale, vscale, 1.);
  gl_StrokeString (p.str); 
  
  glMatrixMode (GL_MODELVIEW);
  glPopMatrix();
  glMatrixMode (GL_PROJECTION);
  glPopMatrix();  

  return true;
}

/**
# *labels()*: displays label fields */

struct _labels {
  char * f;
  float lc[3], lw; // the line color and width
};

trace
bool labels (struct _labels p)
{
#if dimension == 2
  bool expr = false;
  scalar f = compile_expression (p.f, &expr);
  if (f.i < 0)
    return false;
  bview * view = draw();
  float width  = gl_StrokeWidth ('1'), height = gl_StrokeHeight();
  float res = view->res;
  if (view->res < 150*view->samples)
    view->res = 150*view->samples;
  draw_lines (view, p.lc, p.lw) {
    glMatrixMode (GL_MODELVIEW);
    foreach_visible (view)
      if (f[] != nodata) {
	glPushMatrix();
	char s[80];
	sprintf (s, "%g", f[]);
	float scale = 0.8*Delta_x/(strlen(s)*width);
	glTranslatef (x - 0.4*Delta_x, y - scale*height/3., 0.);
	glScalef (scale, scale, 1.);
	gl_StrokeString (s);
	glPopMatrix();
      }
  }
  view->res = res;
  if (expr) delete ({f});
  return true;
#else // dimension == 3
  fprintf (stderr, "labels() is not implemented in 3D yet\n");
  return false;
#endif // dimension == 3
}

/**
# Interface export

This is used by [bview](bview/README) to automatically generate the
user interface. */

#include "draw_json.h"

struct {
  int (* json) (void * q, char * s, int len);
} bview_interface[] = {
  { _draw_vof_json },
  { _squares_json },
  { _cells_json },
  { _box_json },
#if dimension == 2
  { _isoline_json },
  { _labels_json },
  { _vectors_json },
#else // dimension == 3
  { _isosurface_json },
#endif
  { NULL }
};

#endif
